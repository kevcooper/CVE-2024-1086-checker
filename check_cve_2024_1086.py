import json
import re
import subprocess
from pathlib import Path
from typing import Dict, List


def __kconfig(version):
    defaults = {
        "CONFIG_INIT_ON_ALLOC_DEFAULT_ON": "n",
        "CONFIG_INIT_ON_FREE_DEFAULT_ON": "n",
        "CONFIG_NF_TABLES": "n",
        "CONFIG_USER_NS": "n",
    }
    boot_config: Path = Path(f"/boot/config-{version}")
    boot_config_text: str = boot_config.read_text().strip()
    kconfig: Dict[str, str] = text_to_kv(boot_config_text)
    kconfig = {k: v for k, v in kconfig.items() if k in defaults}

    return {**defaults, **kconfig}


def __sysctl():
    defaults = {"kernel.unprivileged_userns_clone": "0"}
    sysctl_text: str = _sysctl(["-a"])
    sysctl: Dict[str, str] = text_to_kv(sysctl_text)
    sysctl = {k: v for k, v in sysctl.items() if k in defaults}

    return {**defaults, **sysctl}


def __cmdline():
    defaults = {"init_on_alloc": "0", "init_on_free": "0"}
    proc_cmdline: Path = Path("/proc/cmdline")
    proc_cmdline_text: str = proc_cmdline.read_text().strip()
    cmdline: Dict[str, str] = text_to_kv(proc_cmdline_text)
    cmdline = {k: v for k, v in cmdline.items() if k in defaults}

    return {**defaults, **cmdline}


def __modules():
    defaults = {"nf_tables": ""}
    proc_modules: Path = Path(f"/proc/modules")
    proc_modules_text: str = proc_modules.read_text().strip()
    proc_modules_lines: List[str] = [l.strip() for l in proc_modules_text.splitlines()]
    proc_modules_lines = [l.split(" ") for l in proc_modules_lines]
    modules: Dict[str, str] = {
        x[0]: x[4] for x in proc_modules_lines if x[0] in defaults
    }

    return {**defaults, **modules}


def _sysctl(flags: List[str]) -> str:
    r = subprocess.run(["sysctl", *flags], capture_output=True)
    return r.stdout.decode() if r.returncode == 0 else ""


def text_to_kv(text: str) -> Dict[str, str]:
    kv_pattern: re.Pattern = re.compile(r"\s*?(.*?)\s*=\s*(.*)")
    items = text.splitlines()
    items = [i.strip() for i in items if i != ""]
    items = [i for i in items if not i.startswith("#")]
    items = [kv_pattern.findall(i) for i in items]
    items = [i[0] for i in items]
    items = [i for i in items if len(i) >= 2]
    return {x[0]: x[1] for x in items}


# https://nvd.nist.gov/vuln/detail/CVE-2024-1086
def check_version(version: str) -> bool:
    return any(
        [
            "3.15" <= version < "6.1.76",
            "6.2" <= version < "6.6.15",
            "6.7" <= version < "6.7.3",
            "6.8.0" <= version <= "6.8.0",
        ]
    )


def do_assert(key, expected, actual):
    assert expected == actual, f"{key}: expected {expected}, got {actual}"


def detect(kconfig, cmdline, sysctl, modules, key_filter=[]):
    if kconfig["CONFIG_NF_TABLES"] in ["m", "y"]:
        kconfig["CONFIG_NF_TABLES"] = "y"
    expected_kconfig = {
        "CONFIG_INIT_ON_ALLOC_DEFAULT_ON": "n",
        "CONFIG_INIT_ON_FREE_DEFAULT_ON": "n",
        "CONFIG_NF_TABLES": "y",
        "CONFIG_USER_NS": "y",
    }
    expected_cmdline = {"init_on_alloc": "0", "init_on_free": "0"}
    expected_sysctl = {"kernel.unprivileged_userns_clone": "1"}
    expected_modules = {"nf_tables": "Live"}

    for k in key_filter:
        expected_kconfig.pop(k, None)
        kconfig.pop(k, None)
        expected_cmdline.pop(k, None)
        cmdline.pop(k, None)
        expected_sysctl.pop(k, None)
        sysctl.pop(k, None)
        expected_modules.pop(k, None)
        modules.pop(k, None)

    for k in kconfig:
        do_assert(k, expected_kconfig[k], kconfig[k])
    for k in cmdline:
        do_assert(k, expected_cmdline[k], cmdline[k])
    for k in sysctl:
        do_assert(k, expected_sysctl[k], sysctl[k])
    for k in modules:
        do_assert(k, expected_modules[k], modules[k])

    return True


def main():
    proc_version: Path = Path("/proc/version")
    proc_version_text: str = proc_version.read_text().strip()
    version_pattern: re.Pattern = re.compile(r"Linux version (.*?)\s")
    version_matches: str = version_pattern.findall(proc_version_text)
    full_version: str = version_matches[0] if version_matches else ""
    short_version = full_version.split("-")[0]

    key_filter = []
    if "6.4.0" <= short_version:
        print("[+] Include init_on_alloc check because 6.4.0 <= version")
        kconfig = __kconfig(full_version)
        cmdline = __cmdline()
    else:
        key_filter = ["CONFIG_INIT_ON_ALLOC_DEFAULT_ON", "init_on_alloc"]
        kconfig = __kconfig(full_version)
        cmdline = __cmdline()

    sysctl = __sysctl()
    modules = __modules()

    print("=" * 64)
    print("CVE-2024-1086 Privesc Check")
    print("kernel version:", full_version)
    print("/boot/config*:", json.dumps(kconfig))
    print("/proc/cmdline:", json.dumps(cmdline))
    print("/proc/modules:", json.dumps(modules))
    print("sysctl -a:", json.dumps(sysctl))

    if check_version(short_version):
        print(f"[+] version {short_version} is vulnerable")
        try:
            if detect(kconfig, cmdline, sysctl, modules, key_filter=key_filter):
                print("[+] WARNING! KERNEL CONFIG IS VULNERABLE")
        except AssertionError as e:
            print("[+] you were saved by:", {str(e)})
            print("[+] kernel config is not vulnerable")
    else:
        print(f"[+] version {short_version} is not vulnerable")
    print("=" * 64)


if __name__ == "__main__":
    main()
